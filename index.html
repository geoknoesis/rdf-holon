<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>RDF-H: A Holonic Modeling Pattern for RDF</title>
    <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove"></script>
    <script class="remove">
        /* ReSpec configuration */
        var respecConfig = {
            // Configuration to remove W3C branding
            useW3CStyle: false,
            specStatus: "unofficial",

            // General Metadata
            shortName: "rdf-h",
            editors: [{
                name: "Stephane Fellah",
                url: "https://geoknoesis.com",
                company: "Geoknoesis LLC",
                companyURL: "https://geoknoesis.com"
            }],
            version: "0.3",
            github: "https://github.com/geoknoesis/rdf-holon",
            copyrightStart: "2025",
            license: "w3c-software-doc",
            localBiblio: {
                "RDF12-CONCEPTS": {
                    title: "RDF 1.2 Concepts and Abstract Syntax",
                    href: "https://www.w3.org/TR/rdf12-concepts/",
                    publisher: "W3C"
                },
                "RDF12-SEMANTICS": {
                    title: "RDF 1.2 Semantics",
                    href: "https://www.w3.org/TR/rdf12-semantics/",
                    publisher: "W3C"
                },
                "RDF12-TURTLE": {
                    title: "RDF 1.2 Turtle",
                    href: "https://www.w3.org/TR/rdf12-turtle/",
                    publisher: "W3C"
                },
                "RDF11-CONCEPTS": {
                    title: "RDF 1.1 Concepts and Abstract Syntax",
                    href: "https://www.w3.org/TR/rdf11-concepts/",
                    publisher: "W3C"
                },
                "RDF11-DATASETS": {
                    title: "RDF 1.1: On the Semantics of RDF Datasets",
                    href: "https://www.w3.org/TR/rdf11-datasets/",
                    publisher: "W3C"
                },
                "SPARQL11-QUERY": {
                    title: "SPARQL 1.1 Query Language",
                    href: "https://www.w3.org/TR/sparql11-query/",
                    publisher: "W3C"
                },
                "SPARQL11-ENTAILMENT": {
                    title: "SPARQL 1.1 Entailment Regimes",
                    href: "https://www.w3.org/TR/sparql11-entailment/",
                    publisher: "W3C"
                },
                "SHACL": {
                    title: "Shapes Constraint Language (SHACL)",
                    href: "https://www.w3.org/TR/shacl/",
                    publisher: "W3C"
                },
                "JSON-LD11": {
                    title: "JSON-LD 1.1",
                    href: "https://www.w3.org/TR/json-ld11/",
                    publisher: "W3C"
                },
                "JSON-LD-STAR": {
                    title: "JSON-LD-star",
                    href: "https://json-ld.github.io/json-ld-star/",
                    publisher: "JSON for Linking Data Community Group"
                },
                "RFC2119": {
                    title: "Key words for use in RFCs to Indicate Requirement Levels",
                    href: "https://www.rfc-editor.org/info/rfc2119",
                    authors: ["S. Bradner"],
                    date: "March 1997",
                    publisher: "IETF"
                },
                "OEP-PARTWHOLE": {
                    title: "Simple Part-Whole Relations in OWL Ontologies",
                    href: "https://www.w3.org/2001/sw/BestPractices/OEP/SimplePartWhole/",
                    publisher: "W3C"
                },
                "SEP-SELFREF": {
                    title: "Self-Reference",
                    href: "https://plato.stanford.edu/entries/self-reference/",
                    publisher: "The Stanford Encyclopedia of Philosophy"
                }
            },
            otherLinks: [{
                key: "Version control",
                data: [{
                    value: "GitHub Repository",
                    href: "https://github.com/geoknoesis/rdf-holon"
                }]
            }]
        };
    </script>
</head>

<body>
    <section id="abstract">
        <p>
            This document specifies <strong>RDF-H</strong>, a vocabulary and modeling pattern for representing
            holarchic structures within the Resource Description Framework 1.2. A holarchy is a system of
            <strong>holons</strong>, where each holon is a resource that is simultaneously a whole in itself and a part
            of a larger whole. RDF-H provides a semantically precise and structurally native method for representing
            nested, contextual, and compositional knowledge by leveraging the capabilities of RDF-star. It introduces a
            core vocabulary centered on the <code>h:inHolon</code> property to link relationships to their
            containing holon, and a formal mereological hierarchy of part-whole relations. This specification also
            proposes <strong>Turtle-H</strong>, a syntactic extension to Turtle providing a concise block-style syntax
            for defining holons, making the pattern intuitive and easy to use. By grounding containment in formal
            mereology and ensuring full backward compatibility with RDF 1.2, RDF-H enables the robust modeling of
            digital twins, cyber-physical systems, fine-grained access control policies, and other domains requiring a
            native understanding of "wholes-within-wholes."
        </p>
    </section>

    <section id="sotd">
        <p>
            <strong>This document is a draft proposal produced by Geoknoesis LLC.</strong> It is not an official
            specification produced by the W3C, nor is it an official work item of any W3C Group. This document is
            published with the aim of gathering feedback from the community for potential future submission to and
            standardization by the W3C.
        </p>
    </section>

    <section id="intro" class="informative">
        <h2>Introduction and Motivation</h2>
        <p>
            The Resource Description Framework (RDF) provides a powerful, graph-based data model for representing
            information about resources and the relationships between them. Its core structure, a set of
            subject-predicate-object triples, creates a directed, labeled graph that is flexible, extensible, and
            web-scalable. However, the "flat" nature of this graph, where all triples exist at the same structural
            level, presents significant challenges when modeling systems that possess inherent compositional or
            contextual hierarchies.
        </p>
        <p>
            The key words <em class="rfc2119" title="MUST">MUST</em>, <em class="rfc2119" title="MUST NOT">MUST
                NOT</em>, <em class="rfc2119" title="SHOULD">SHOULD</em>, and <em class="rfc2119" title="MAY">MAY</em>
            in this document are to be interpreted as described in [[RFC2119]].
        </p>

        <section>
            <h3>The Need for a Compositional Modeling Pattern</h3>
            <p>
                Many real-world and conceptual domains are fundamentally compositional. A car is a whole composed of
                parts like an engine and wheels; the engine, in turn, is a whole composed of its own parts. A digital
                twin of a factory floor is a whole that contains digital twins of individual assembly lines, which in
                turn contain twins of robotic arms. In systems biology, a cell contains organelles, which contain
                molecular complexes. In all these cases, the identity, boundary, and integrity of a subsystem (the
                "part") are as crucial as the relationships that exist <em>within</em> it.
            </p>
            <p>
                While RDF can <em>describe</em> these part-whole relations using predicates (e.g.,
                <code>ex:engine ex:partOf ex:car</code>), it lacks a simple, standardized pattern to represent this
                containment in a way that is both structurally intuitive and semantically rich. Existing approaches
                require developers to adopt specific modeling conventions or use mechanisms that were designed for
                related but distinct purposes. This leads to semantic ambiguity, complex queries, and a disconnect
                between the intuitive structure of the domain and its representation in the graph. This specification
                for <strong>RDF-H</strong> introduces a vocabulary and modeling pattern to address this gap, providing a
                native, semantically grounded way to model structural composition directly within the graph.
            </p>
        </section>

        <section>
            <h3>Limitations of Existing Approaches: A Comparative Analysis</h3>
            <p>
                The need for a new standardized pattern is best understood by examining the limitations of current RDF
                mechanisms for grouping, contextualizing, and annotating data.
            </p>
            <section>
                <h4>Standard Reification</h4>
                <p>
                    The original RDF specification provided a vocabulary for reification, allowing a statement to be
                    treated as a resource. This approach has several well-documented drawbacks, including verbosity (four
                    extra triples per annotation) and weak semantics (asserting the reification does not assert the
                    original triple).
                </p>
            </section>
            <section>
                <h4>RDF-star (RDF 1.2)</h4>
                <p>
                    RDF-star, now integrated into RDF 1.2, was a major breakthrough that addressed the verbosity of
                    reification by introducing quoted (or embedded) triples as a new type of RDF term
                    [[RDF12-CONCEPTS]]. While immensely useful, RDF-star provides a <strong>mechanism</strong>, not a
                    <strong>pattern</strong>. It is designed to attach metadata to <em>individual edges</em> in the
                    graph, answering the question, "What can be said about this specific relationship?" However, it does
                    not, by itself, provide a standardized way to group a <em>set of relationships</em> into a
                    containing whole. Without a standard like RDF-H, developers would use the RDF-star mechanism with
                    different, incompatible properties (e.g., <code>ex:hasContext</code>, <code>ex:isAbout</code>,
                    <code>ex:partOfGroup</code>) to achieve the same goal, leading to a fragmented ecosystem where graphs
                    cannot be reliably merged or queried. RDF-H solves this by proposing a single, standard vocabulary
                    (<code>h:inHolon</code>) for this purpose.
                </p>
            </section>
            <section>
                <h4>Named Graphs (RDF Datasets)</h4>
                <p>
                    Named graphs are the most common mechanism in RDF for grouping triples [[RDF11-DATASETS]]. However, a
                    deeper analysis reveals that it is fundamentally a data management feature, not a resource modeling
                    primitive, with critical limitations for representing holonic structures:
                </p>
                <ul>
                    <li><strong>Dataset-Level Partitioning, Not Resource-Level Composition:</strong> Named graphs
                        partition the entire triple store into distinct, named sets of triples. In contrast, RDF-H
                        establishes a compositional relationship <em>between resources within a single, unified
                            graph</em>.</li>
                    <li><strong>Ambiguous Semantics:</strong> The semantics of a graph name are notoriously
                        underspecified. This ambiguity makes named graphs unsuitable for precise, model-theoretic
                        representation of part-whole relations.</li>
                    <li><strong>Querying Paradigm:</strong> Querying across named graphs in SPARQL requires the
                        <code>GRAPH</code> clause, which changes the <em>active graph</em>. This is a meta-level
                        operation on the dataset, not a traversal of a relationship within the graph.
                    </li>
                </ul>
                <p>RDF-H, as proposed in this specification, offers a solution that is semantically precise, operates at
                    the resource level, and is designed for native traversal-based querying.</p>
                <table class="def">
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Standard Reification</th>
                            <th>RDF-star (RDF 1.2)</th>
                            <th>Named Graphs (RDF 1.1)</th>
                            <th><strong>RDF-H Pattern</strong></th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Granularity</strong></td>
                            <td>Single Statement</td>
                            <td>Single Statement</td>
                            <td>Set of Statements (Graph)</td>
                            <td>Set of Relationships (Composition)</td>
                        </tr>
                        <tr>
                            <td><strong>Semantic Precision</strong></td>
                            <td>Weak (describes a statement token)</td>
                            <td>Strong (annotates a proposition)</td>
                            <td>Ambiguous (multiple interpretations of graph name)</td>
                            <td>Strong (formal mereological relation)</td>
                        </tr>
                        <tr>
                            <td><strong>Syntactic Verbosity</strong></td>
                            <td>High (4 extra triples)</td>
                            <td>Low (<code>&lt;&lt;...&gt;&gt;</code>)</td>
                            <td>Moderate (quads)</td>
                            <td>Low (proposed <code>{...}</code> syntax)</td>
                        </tr>
                        <tr>
                            <td><strong>Querying Paradigm</strong></td>
                            <td>Complex Joins</td>
                            <td>SPARQL-star Patterns</td>
                            <td><code>GRAPH</code> Clause (Scope Change)</td>
                            <td>Property Path Traversal</td>
                        </tr>
                        <tr>
                            <td><strong>Core Use Case</strong></td>
                            <td>Provenance of a statement token</td>
                            <td>Metadata on a statement</td>
                            <td>Dataset management, provenance</td>
                            <td>Modeling structural composition</td>
                        </tr>
                    </tbody>
                </table>
            </section>
        </section>
    </section>

    <section id="conformance">
        <h2>Conformance Criteria</h2>
        <p>This specification defines two classes of conformance.</p>
        <p>A conformant <strong>RDF-H Processor</strong> <em class="rfc2119" title="MUST">MUST</em>:</p>
        <ol>
            <li>Satisfy all conformance criteria for a fully conformant RDF 1.2 processor, including support for RDF 1.2
                Datasets and the RDF-star data model and syntaxes.</li>
            <li>Correctly parse and serialize the Turtle-H syntax defined in <a href="#syntax" class="sec-ref"></a>,
                translating it to and from the standard RDF-star representation.</li>
            <li>Support an entailment regime that respects the RDFS and OWL semantics of the RDF-H vocabulary defined in
                <a href="#semantics" class="sec-ref"></a>.</li>
        </ol>
        <p>A conformant <strong>RDF-H Graph</strong> <em class="rfc2119" title="MUST">MUST</em>:</p>
        <ol>
            <li>Be a valid RDF 1.2 graph.</li>
            <li>Adhere to the modeling patterns defined in this specification.</li>
            <li>Not contain any cycles in its part-whole relationship hierarchies.</li>
        </ol>
    </section>

    <section id="vocabulary">
        <h2>The RDF-H Vocabulary</h2>
        <p>This section defines the core vocabulary for the RDF-H modeling pattern. The vocabulary namespace is
            <code>https://w3id.org/rdf-h#</code>, bound by convention to the prefix <code>h:</code>.
        </p>

        <section>
            <h3>Core Class and Property</h3>
            <dl>
                <dt><dfn data-dfn-type="dfn" id="dfn-holon-class" class="export">h:Holon</dfn></dt>
                <dd>The class of all holons. A holon is a resource that acts as a context for other relationships,
                    representing a "whole" composed of "parts". Designating a resource as a <code>h:Holon</code>
                    indicates it can be the object of an <code>h:inHolon</code> triple.</dd>

                <dt><dfn data-dfn-type="dfn" id="dfn-inholon-property" class="export">h:inHolon</dfn></dt>
                <dd>An object property that links a reified triple (a relationship) to the holon it is a constituent
                    part of. The subject of this property is a quoted triple, and the object is the containing holon.
                    The <code>rdfs:range</code> of this property is <code>h:Holon</code>.
                </dd>
            </dl>
        </section>

        <section id="part-of-hierarchy">
            <h3>The Part-Of Hierarchy</h3>
            <p>To provide semantic precision, RDF-H defines a hierarchy of part-whole relationships using
                <code>rdfs:subPropertyOf</code> and <code>owl:inverseOf</code>. This allows modelers to be specific
                while allowing queries to be general. The top-level <code>h:partOf</code> property is transitive, but its
                sub-properties are not, preventing incorrect inferences across holarchic levels. [[OEP-PARTWHOLE]]</p>
            <dl>
                <dt><code>h:partOf</code> / <code>h:hasPart</code></dt>
                <dd>The top-level, transitive super-property for all part-whole relations. <code>h:hasPart</code> is the
                    inverse of <code>h:partOf</code>.
                    <br><strong>Characteristics:</strong> Transitive.
                </dd>

                <dt><code>h:componentOf</code> / <code>h:hasComponent</code></dt>
                <dd>A sub-property of <code>h:partOf</code> for functional or structural parts (e.g., an engine is a
                    component of a car). This relationship is essential for preserving the distinct levels of a holarchy.
                    <code>h:hasComponent</code> is the inverse of <code>h:componentOf</code>.
                    <br><strong>Characteristics:</strong> Non-transitive.
                </dd>

                <dt><code>h:memberOf</code> / <code>h:hasMember</code></dt>
                <dd>A sub-property of <code>h:partOf</code> for elements in a collection or group where the whole is an
                    aggregate of its members (e.g., a player is a member of a team). <code>h:hasMember</code> is the
                    inverse of <code>h:memberOf</code>.
                    <br><strong>Characteristics:</strong> Non-transitive.
                </dd>

                <dt><code>h:substanceOf</code> / <code>h:hasSubstance</code></dt>
                <dd>A sub-property of <code>h:partOf</code> for material composition (e.g., clay is a substance of a
                    brick). A part of the substance is also a part of the whole. <code>h:hasSubstance</code> is the
                    inverse of <code>h:substanceOf</code>.
                    <br><strong>Characteristics:</strong> Transitive.
                </dd>

                <dt><code>h:portionOf</code> / <code>h:hasPortion</code></dt>
                <dd>A sub-property of <code>h:partOf</code> for segments of a continuous whole (e.g., a slice is a
                    portion of a pie). A part of the portion is also a part of the whole. <code>h:hasPortion</code> is the
                    inverse of <code>h:portionOf</code>.
                    <br><strong>Characteristics:</strong> Transitive.
                </dd>
            </dl>
            <div class="example">
                <p><strong>Ontology Definition (Turtle):</strong></p>
                <pre class="nohighlight turtle">
@prefix h: &lt;https://w3id.org/rdf-h#&gt; .
@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .
@prefix owl: &lt;http://www.w3.org/2002/07/owl#&gt; .

# Top-level properties
h:partOf a owl:ObjectProperty, owl:TransitiveProperty .
h:hasPart a owl:ObjectProperty, owl:TransitiveProperty ;
    owl:inverseOf h:partOf .

# Non-transitive sub-properties
h:componentOf a owl:ObjectProperty ;
    rdfs:subPropertyOf h:partOf .
h:hasComponent a owl:ObjectProperty ;
    rdfs:subPropertyOf h:hasPart ;
    owl:inverseOf h:componentOf .

h:memberOf a owl:ObjectProperty ;
    rdfs:subPropertyOf h:partOf .
h:hasMember a owl:ObjectProperty ;
    rdfs:subPropertyOf h:hasPart ;
    owl:inverseOf h:memberOf .

# Transitive sub-properties
h:substanceOf a owl:ObjectProperty, owl:TransitiveProperty ;
    rdfs:subPropertyOf h:partOf .
h:hasSubstance a owl:ObjectProperty, owl:TransitiveProperty ;
    rdfs:subPropertyOf h:hasPart ;
    owl:inverseOf h:substanceOf .

h:portionOf a owl:ObjectProperty, owl:TransitiveProperty ;
    rdfs:subPropertyOf h:partOf .
h:hasPortion a owl:ObjectProperty, owl:TransitiveProperty ;
    rdfs:subPropertyOf h:hasPart ;
    owl:inverseOf h:portionOf .
</pre>
            </div>
        </section>

        <section>
            <h3>Exclusion of Other Relationship Types</h3>
            <p>
                It is a deliberate design choice for the RDF-H vocabulary to focus exclusively on composition
                (<code>h:inHolon</code>) and mereology (the <code>h:partOf</code> hierarchy). Other important
                relationship types, such as peer-to-peer, dependency, or hierarchical supervision, are considered
                <strong>domain-specific</strong> and are intentionally excluded from this core vocabulary.
            </p>
            <p>
                This design follows the principle of minimality. RDF-H provides the universal, structural primitives for
                building holarchies. Modelers are encouraged to define their own domain-specific properties (e.g.,
                <code>ex:isPeerOf</code>, <code>ex:dependsOn</code>) in their own ontologies. The RDF-H pattern is then
                used to place these custom relationships within the context of a holon. This approach promotes a more
                flexible and composable ecosystem, where the core RDF-H pattern can be applied to any relationship,
                without the RDF-H vocabulary itself becoming an exhaustive and overly prescriptive ontology.
            </p>
            <div class="example">
                <p><strong>Example of using a domain-specific property with RDF-H:</strong></p>
                <pre class="nohighlight turtle">
@prefix ex: &lt;http://example.org/network#&gt; .
@prefix h: &lt;https://w3id.org/rdf-h#&gt; .

# A domain-specific property defined in an external ontology
ex:isPeerOf a owl:ObjectProperty, owl:SymmetricProperty .

# Applying the RDF-H pattern to the domain-specific property
ex:SystemCluster {
    ex:ServiceA ex:isPeerOf ex:ServiceB .
}
</pre>
            </div>
        </section>
    </section>

    <section id="semantics">
        <h2>Formal Semantics and Entailment</h2>
        <p>
            The semantics of RDF-H are defined by the standard RDF 1.2 model-theoretic semantics [[RDF12-SEMANTICS]]
            applied to graphs containing the RDF-H vocabulary. No new entailment regime is required; rather, standard
            RDFS or OWL reasoners will produce the desired inferences based on the ontology.
        </p>

        <section>
            <h3>Holon Inference</h3>
            <p>
                The primary inference in RDF-H is the typing of a resource as a <code>h:Holon</code>. This is achieved
                via the <code>rdfs:range</code> axiom on the <code>h:inHolon</code> property.
            </p>
            <div class="example">
                <p><strong>Ontology Axiom (Turtle):</strong></p>
                <pre class="nohighlight turtle">
@prefix h: &lt;https://w3id.org/rdf-h#&gt; .
@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .

h:inHolon rdfs:range h:Holon .
</pre>
                <p><strong>Entailment Rule (h-holon-type):</strong></p>
                <pre>
IF:   &lt;&lt; ?s ?p ?o &gt;&gt; h:inHolon ?c .
THEN: ?c rdf:type h:Holon .
                </pre>
                <p>
                    This rule means that any resource appearing as the object of an <code>h:inHolon</code> triple
                    is inferred to be an instance of <code>h:Holon</code>.
                </p>
            </div>
        </section>

        <section>
            <h3>Part-Whole Inference</h3>
            <p>
                Queries for the general <code>h:partOf</code> property will entail results from all its
                sub-properties.
            </p>
            <div class="example">
                <p><strong>Data:</strong></p>
                <pre class="nohighlight turtle">
ex:Engine h:componentOf ex:Car .
ex:Player h:memberOf ex:Team .
</pre>
                <p><strong>Query:</strong></p>
                <pre class="nohighlight sparql">
SELECT ?part ?whole WHERE { ?part h:partOf ?whole . }
</pre>
                <p>An RDFS-aware reasoner will return both the engine-car and player-team pairs, because it knows that
                    <code>h:componentOf</code> and <code>h:memberOf</code> are sub-properties of <code>h:partOf</code>.
                </p>
            </div>
        </section>

        <section>
            <h3>Acyclicity and Well-Foundedness</h3>
            <p>
                The requirement that part-whole hierarchies be acyclic is a fundamental guarantee of the
                logical soundness of any compositional model. It is analogous to the Axiom of Foundation in
                Zermelo–Fraenkel set theory, which prevents self-referential paradoxes [[SEP-SELFREF]].
            </p>
            <p>
                Therefore, a conformant <strong>RDF-H Graph</strong> <em class="rfc2119" title="MUST NOT">MUST
                    NOT</em> contain cycles in its part-whole relationship paths (e.g.,
                <code>H1 h:partOf H2 . H2 h:partOf H1 .</code>). Such a graph is logically inconsistent. This can be
                enforced using SHACL, as described in <a href="#validation" class="sec-ref"></a>.
            </p>
        </section>
    </section>

    <section id="syntax">
        <h2>Turtle-H: A Syntactic Sugar for Turtle</h2>
        <p>
            To simplify the authoring of holonic structures, this specification proposes <strong>Turtle-H</strong>, a
            syntactic sugar for Turtle that introduces a block-style syntax for defining a holon's context. A conformant
            RDF-H processor <em class="rfc2119" title="SHOULD">SHOULD</em> support this syntax.
        </p>

        <section>
            <h3>The Holon Context Block <code>{...}</code></h3>
            <p>
                A holon and its constituent relationships can be defined by stating the holon's identifier (IRI or blank
                node) followed by a block of Turtle statements enclosed in curly braces <code>{...}</code>.
            </p>
            <p class="note">
                It is important to note that this block-style syntax is <strong>not</strong> part of the standard Turtle
                or Turtle-star specifications. It is a proposed syntactic sugar for RDF-H designed to improve usability.
                In standard Turtle, a developer would be required to manually write two separate triples: the relationship
                itself, and the RDF-star annotation linking it to the holon. The proposed <code>{...}</code> block
                simplifies this by allowing the developer to write the relationship only once; a Turtle-H-aware parser
                then automatically generates both required triples.
            </p>
            <div class="example">
                <p><strong>Example using Turtle-H Syntax:</strong></p>
                <pre class="nohighlight turtle">
@prefix ex: &lt;http://example.org/&gt; .
@prefix h: &lt;https://w3id.org/rdf-h#&gt; .

ex:Car_123 {
    ex:Engine_456 h:componentOf ex:Car_123 .

    ex:Engine_456 {
        ex:Piston_789 h:componentOf ex:Engine_456 .
    }
}
</pre>
            </div>
            <p>
                This concise syntax is syntactic sugar for the more verbose standard RDF-star representation. A Turtle-H
                parser <em class="rfc2119" title="MUST">MUST</em> translate the block syntax into the equivalent set of
                standard triples.
            </p>
            <p>The block <code>:H { :s :p :o . }</code> "desugars" into the following two standard triples:</p>
            <ol>
                <li><strong>The Base Fact:</strong> The relationship itself is asserted.
                    <br><code>:s :p :o .</code>
                </li>
                <li><strong>The Context Fact:</strong> The relationship is linked to its containing holon.
                    <br><code>&lt;&lt; :s :p :o &gt;&gt; h:inHolon :H .</code>
                </li>
            </ol>
            <div class="example">
                <p><strong>Standard RDF-star Equivalent of the Turtle-H Example:</strong></p>
                <pre class="nohighlight turtle">
@prefix ex: &lt;http://example.org/&gt; .
@prefix h: &lt;https://w3id.org/rdf-h#&gt; .

# Triples generated from the ex:Car_123 context
ex:Engine_456 h:componentOf ex:Car_123 .
&lt;&lt; ex:Engine_456 h:componentOf ex:Car_123 &gt;&gt; h:inHolon ex:Car_123 .

# Triples generated from the nested ex:Engine_456 context
ex:Piston_789 h:componentOf ex:Engine_456 .
&lt;&lt; ex:Piston_789 h:componentOf ex:Engine_456 &gt;&gt; h:inHolon ex:Engine_456 .
</pre>
            </div>
            <p>
                This syntactic sugar dramatically improves readability and writability, making the holonic structure
                visually apparent while remaining 100% compatible with the standard RDF 1.2 data model.
            </p>
        </section>
    </section>

    <section id="querying">
        <h2>Querying Holonic Graphs with SPARQL</h2>
        <p>
            Querying RDF-H graphs does not require any extension to SPARQL. All holonic structures can be queried using
            standard SPARQL 1.1 [[SPARQL11-QUERY]] combined with SPARQL-star patterns.
        </p>

        <section>
            <h3>Querying Holonic Context</h3>
            <p>The core pattern for querying within a holon's context involves finding relationships linked to it via
                <code>h:inHolon</code>.</p>
            <div class="example">
                <p><strong>Example Query:</strong> Find all component relationships defined within the context of
                    <code>ex:Engine_456</code>.</p>
                <pre class="nohighlight sparql">
PREFIX ex: &lt;http://example.org/&gt;
PREFIX h:  &lt;https://w3id.org/rdf-h#&gt;

SELECT ?part ?engine
WHERE {
    &lt;&lt; ?part h:componentOf ?engine &gt;&gt; h:inHolon ex:Engine_456 .
}
</pre>
            </div>
        </section>

        <section>
            <h3>Querying Across the Part-Of Hierarchy</h3>
            <p>Standard property paths can be used to query for specific or general part-whole relationships.</p>
            <div class="example">
                <p><strong>Example Query:</strong> Find all components, direct and indirect, of
                    <code>ex:Car_123</code>.</p>
                <pre class="nohighlight sparql">
PREFIX ex: &lt;http://example.org/&gt;
PREFIX h:  &lt;https://w3id.org/rdf-h#&gt;

# This query uses a property path on the specific 'componentOf' relation.
SELECT ?component
WHERE {
  ?component h:componentOf+ ex:Car_123 .
}
</pre>
            </div>
            <div class="example">
                <p><strong>Example Query:</strong> Find all parts of <code>ex:Car_123</code>, regardless of the
                    specific relationship type (component, member, etc.).</p>
                <pre class="nohighlight sparql">
PREFIX ex: &lt;http://example.org/&gt;
PREFIX h:  &lt;https://w3id.org/rdf-h#&gt;

# This query uses the general 'partOf' relation. An RDFS-aware engine will
# traverse across all its sub-properties.
SELECT ?part
WHERE {
  ?part h:partOf+ ex:Car_123 .
}
</pre>
            </div>
        </section>
    </section>

    <section id="validation">
        <h2>Validation with SHACL</h2>
        <p>
            The Shapes Constraint Language (SHACL) [[SHACL]] is the standard mechanism for validating RDF graphs. To
            facilitate the validation of holonic graphs, the RDF-H vocabulary includes two built-in
            <strong>Constraint Components</strong>. These components encapsulate the core structural integrity rules of
            the RDF-H pattern, making it simpler to write robust and reusable SHACL shapes. A conformant SHACL-H
            processor <em class="rfc2119" title="SHOULD">SHOULD</em> recognize and implement these components.
        </p>

        <section>
            <h3>Built-in Constraint Component: AcyclicPartConstraintComponent</h3>
            <p>
                This component validates the most critical structural rule: that the part-whole hierarchy must be
                acyclic. A holon cannot be a part of itself, either directly or indirectly.
            </p>
            <ul>
                <li><strong>IRI:</strong> <code>h:AcyclicPartConstraintComponent</code></li>
                <li><strong>Constraint:</strong> A focus node violates this constraint if there exists a non-empty
                    property path of <code>h:partOf</code> from the focus node back to itself.</li>
            </ul>
            <div class="example">
                <p><strong>Example SHACL Shape using the component:</strong></p>
                <pre class="nohighlight turtle">
ex:AcyclicPartShape
    a sh:NodeShape ;
    sh:targetClass h:Holon ;
    sh:constraint [
        a h:AcyclicPartConstraintComponent ;
        sh:message "The holon participates in a part-of cycle." ;
    ] .
</pre>
            </div>
            <div class="example">
                <p><strong>Formal Definition of the Validator:</strong></p>
                <pre class="nohighlight turtle">
h:AcyclicPartConstraintComponent a sh:ConstraintComponent ;
    sh:validator h:AcyclicPartValidator .

h:AcyclicPartValidator a sh:SPARQLValidator ;
    sh:message "The focus node participates in a part-of cycle."@en ;
    sh:select """
        PREFIX h: <https://w3id.org/rdf-h#>
        SELECT $this
        WHERE {
            $this h:partOf+ $this .
        }
    """ .
</pre>
            </div>
        </section>

        <section>
            <h3>Built-in Constraint Component: HolonIntegrityConstraintComponent</h3>
            <p>
                This component validates that any resource acting as a holon (i.e., as the object of an
                <code>h:inHolon</code> property) is explicitly declared to be of type <code>h:Holon</code>.
            </p>
            <ul>
                <li><strong>IRI:</strong> <code>h:HolonIntegrityConstraintComponent</code></li>
                <li><strong>Constraint:</strong> A focus node violates this constraint if it is the object of an
                    <code>h:inHolon</code> triple but is not explicitly declared as an <code>rdf:type</code> of
                    <code>h:Holon</code>.
                </li>
            </ul>
            <div class="example">
                <p><strong>Example SHACL Shape using the component:</strong></p>
                <pre class="nohighlight turtle">
ex:HolonIntegrityShape
    a sh:NodeShape ;
    sh:targetObjectsOf h:inHolon ;
    sh:constraint [
        a h:HolonIntegrityConstraintComponent ;
        sh:message "This resource is used as a holon but is not typed as h:Holon." ;
    ] .
</pre>
            </div>
            <div class="example">
                <p><strong>Formal Definition of the Validator:</strong></p>
                <pre class="nohighlight turtle">
h:HolonIntegrityConstraintComponent a sh:ConstraintComponent ;
    sh:validator h:HolonIntegrityValidator .

h:HolonIntegrityValidator a sh:SPARQLValidator ;
    sh:message "The focus node is used as a holon (object of h:inHolon) but is not typed as h:Holon."@en ;
    sh:select """
        PREFIX h: <https://w3id.org/rdf-h#>
        SELECT $this
        WHERE {
            ?s h:inHolon $this .
            FILTER NOT EXISTS { $this a h:Holon . }
        }
    """ .
</pre>
            </div>
        </section>
    </section>


    <section id="conclusion" class="informative">
        <h2>Conclusion</h2>
        <p>
            This specification introduces <strong>RDF-H</strong>, a powerful and flexible modeling pattern for
            representing compositional structures in RDF. By leveraging the existing capabilities of RDF 1.2 and
            RDF-star, it provides a semantically sound and structurally intuitive method for modeling "wholes-within-wholes."
            The core vocabulary, centered on <code>h:inHolon</code> and a formal mereological hierarchy, is both
            simple and expressive. The proposed Turtle-H syntactic sugar makes the pattern highly accessible to
            developers, bridging the gap between the intuitive feel of property graphs and the formal rigor of RDF.
            RDF-H provides a robust, standards-based foundation for the next generation of knowledge graphs in domains
            such as digital twins, systems engineering, contextual AI, and the Spatial Web.
        </p>
    </section>

    <section id="acknowledgements" class="appendix">
        <h2>Acknowledgements</h2>
        <p>The editors thank the RDF-star Community Group and the wider RDF-Dev community for early feedback and
            valuable discussions that have shaped this specification.</p>
    </section>
</body>

</html>
